# Java基础笔记



JVM

Java字节码执行环境（执行引擎+自动内存管理+类加载器）

重点：```类的加载过程```，```类加载器```，```JVM内存区域```，```堆```，```堆内存的配置```，```FullGC排查```，```OOM```

Java程序分为编译和执行两个阶段，编译阶段做的事情比较单纯直接，就是翻译，翻译没有什么好搞的，最多就是注意一些我们 常用的java语言的功能具体在虚拟机是用什么实现的，比如 synchronized 关键字实际上是使用JVM当中的 monitor_enter 和 monitor_exit 指令，枚举实际上是用 static final 常量来实现的等等。



到了运行阶段，就涉及到JVM了，JVM首先要将类的字节码文件加载到虚拟机当中，才能运行代码逻辑，说到类加载，就得从类加载器开始，类加载器有几个特点：

1. 每个类加载器加载类的路径一般不同；
2. 不同类加载器加载的类，即使类的全限定名相同，仍然是不同的类，可以在JVM当中共存；



Tomcat是类加载器运用非常到位的一个servlet容器，他的类加载器设计是为了几个目标：

1. 多个web应用可能使用版本不同的类，所以不同的web应用类之间需要隔离；
2. 不同web应用可以共享部分类；
3. tomcat容器有自己依赖的类，需要和web应用使用的类隔离；
4. jsp需要实现热加载，实现机制就是一个jsp文件使用一个类加载器，jsp修改后，新类加载器重新加载jsp



![img](https://images2018.cnblogs.com/blog/137084/201805/137084-20180526104342525-959933190.png)

使用父类加载器，可以让多个类加载器共享某些加载的类，而不同的类加载器则可以进行类的隔离，









面向对象

重点：多态的原理



内置数据类型

重点：集合（List, Set, Queue, Map）



IO

重点：网络IO模型





多线程

重点：线程并发，互斥和同步机制，锁，死锁排查和避免，原子类，线程池，并发容器





高级特性

重点：反射，

















## 多线程





### 设计模式

在多线程环境之下，我们希望有一个目标：

1. **保证程序执行的正确性**，共享资源不会在多线程环境中遭到非预期破坏
2. **提高程序执行性能**



多线程的设计模式，也就是在多线程环境下，设计程序执行流的方式，包括很多种

* ```Single-Thread-Execution模式```

  如果多个线程需要互斥执行（并发操作共享资源），就需要用到这种模式，每次只让一个线程可以执行，从而保证程序执行的正确性

  ⚠️ 主要注意的是，这种模式下，因为线程都是互斥地占用共享资源，需要特别注意死锁问题

  

* ```Immutable模式```

  不变指的是多线程访问的共享资源的不变性，如果共享资源的状态无需改变，那使用不可变模式要比互斥模式性能高得多，因为线程不需要阻塞了嘛，但是这要看我们使用的共享资源的类型，如果共享资源状态在程序运行中不需要变化，则优先选择Immutable模式

  

* ```Guarded Suspension模式```

  

* ```Balking模式```

  

* ```生产者消费者模式```

  

* ```读写模式```

  

* ```Thread-Per-Message模式```

  

* ```Worker Thread模式```

  

* ```Future模式```

  

* ```Two-Pha```

  







### 线程池



#### 简介

所有的池化资源都有的共同特性，不管是线程池，还是数据库连接池，还是String常量池，对象池等等，这些资源其实都有一致的特点，1. 资源比较重，创建和销毁开销大；2. 可复用；

* ```资源复用```，减少资源创建和销毁的开销
* ```资源缓存```，需要用的时候不需要创建，直接就有现成的，用空间换时间思想的延伸
* ```资源控制```，管控核心资源，提高系统的稳定性（线程资源有预期使用范围，可控）



线程池嘛，就是一种对线程资源的池化方式，线程池代表了线程资源，但是Java当中的线程池封装了对线程的使用，我们可以以几种方式来使用线程池，如果单单只是为了复用线程资源，那用 CachedThreadPool 就好了，这种线程池纯粹缓存线程资源，没有任何附加功能；但是线程池还可以和阻塞队列一起用，生产者消费者模式。





#### 参数配置

使用多线程的时候要考虑一个问题，线程池当中的线程数量和阻塞队列如何设置❓

这设计到线程池当中运行的任务究竟是 ```I/O密集型任务```，还是 ```CPU密集型任务```：

如果是I/O密集型任务那其实可以多增加线程，而不是增加队列长度，因为一个任务在执行中，如果需要进行I/O操作，那运行这个任务的线程就会进入阻塞状态，这个时候就相当于一群干活儿的人，干不下去需要等待了，那线程池当中能够运行任务的线程会急剧减少，这个时候就算你新任务等待在队列里又有什么用呢，都没干活儿的人了，所以这个时候，多增加一点线程数才是正确的做法，增加干活儿的人数，即使有些线程因为I/O操作阻塞了，还有闲着的人，而且因为I/O操作时，不占用CPU，同一时刻运行的线程数量是有限的，所以不会有过高的线程上下文开销。

如果是CPU密集型任务，那增加线程数其实并不会多有效果，因为所有线程都在活跃状态，都在运行任务，消耗CPU，你创建那么多线程只会让线程上下文切换更加频繁，反而会降低任务执行的效率。这个时候合适的做法就是增加任务队列的长度，可以缓存更多的任务



但是现实当中情况复杂，如果可以运行时根据具体情况动态调整线程池的参数，可以应对一些突发情况，让线程池还可以运行，不至于让系统崩溃。ThreadPoolExecutor类提供了在线程池运行时动态改变核心参数的方法，也提供了读取当前线程池状态的一些方法

![img](https://tuchuang-1256253537.cos.ap-shanghai.myqcloud.com/img/v2-d217e4c79e7d4e4370fee92cb53efb1a_b.jpg)



![img](https://tuchuang-1256253537.cos.ap-shanghai.myqcloud.com/img/v2-968ffa8338dbebdc395dbb48a7c99aea_b.jpg)



参考：https://zhuanlan.zhihu.com/p/123328822





#### 线程池状态



<img src="https://tuchuang-1256253537.cos.ap-shanghai.myqcloud.com/img/v2-9ff88b126bf859ccb751ee1526e97f8c_r.jpg" alt="preview" style="zoom:65%;" />





#### 线程池种类

从 Executors 的几个静态方法来看，可以发现线程池在使用的时候有几个种类：

* **<span style="color:green">只缓存线程对象的线程池</span>**：对应 ```Executors.newCachedThreadPool()```，核心线程数为0意味着，如果线程池当中的线程超过一定空闲时间，则线程会被销毁，这个线程池适合用在对线程资源要求比较紧张的场景，而且这个线程池使用的是同步队列 SynchronousQueue，并非生产者消费者模式，而是主线程提交一个任务，如果此时没有空闲线程，则主线程阻塞，所以这个线程池只提供缓存的线程，不缓存任务，所以不是生产者消费者模式，纯粹的池化线程；
* **<span style="color:green">并发数固定的线程池</span>**：对应 ```Executors.newFixedThreadPool()```，核心线程数和最大线程数一致，用于控制线程数量
* **<span style="color:green">单线程线程池</span>**：按照FIFO, 优先级（PriorityBlockingQueue，小根堆实现）等顺序执行任务的线程池，通过传入不同类型的BlockingQueue来实现
* **<span style="color:green">执行定时任务的线程池</span>**：使用 DelayedWorkQueue（和PriorityBlockingQueue类似，底层还是使用堆） 实现



看这几个不同类型的线程池，其实就两个核心，一个是 **阻塞队列**，一个是 **线程数量**，控制线程数量一方面可以控制并发度，一方面单线程具有顺序执行的特点，阻塞队列的特点比较多，有一般用来缓存的阻塞队列，有优先级的队列，有同步队列，有延时队列等等。





编程语言是为了让我们 ```快速``` 开发出 ```高质量``` 的应用软件的。

我们对于





## 系统资源抽象

编程语言提供了面向编码人员，操作系统资源的接口

**对内存使用的抽象**：对象就代表一片内存区域，不同类型的对象支持不同类型的操作，按照内存空间的，分为 ```独立的内存空间``` 和 ```连续的内存空间```。



### Java的内存体系

关键词：对象、引用、JVM内存管理

内存有两个关键的指标：```大小```（满足使用要求情况下尽量小）、```使用周期```（不用了及时释放/回收）



**1. 在哪里申请内存**❓

1. ```虚拟机栈帧```，局部变量表（每个变量占用一个槽，一个槽最多存储4字节变量），用完即删，虚拟机栈大小有限制
2. ```堆（Heap）```，存储对象的内存区域，默认创建的对象都存储在堆区域中
3. ```堆外```，堆外内存不受虚拟机堆内存大小限制，不会对GC产生影响



**2. 申请多大的内存**❓

由你使用的数据类型决定，不同数据类型占用的内存空间是不一样的



**3. 内存使用周期**❓

一般情况下，不需要关注内存使用周期，JVM会在适当的时候帮我们回收内存，但是可以使用特定的引用类型来显示标识内存使用周期 强引用（默认）、软引用、弱引用、虚引用







语言力：

1. 面向对象支持：抽象、封装、继承、多态，是构建灵活软件的核心特性，Java支持单继承和多接口实现
2. 完善的异常处理机制：方便构建鲁棒性强的软件
3. 支持泛型：提高效率
4. 集合框架：丰富的数据类型，用起来真香
5. 多线程支持：充分利用多核提高程序性能



### 基本数据结构











数组，链表，散列表，集合，队列，堆，树

