# web/应用服务器



## 基本问题

不管是web还是应用服务器，作为服务器和客户端进行交互，都要处理两个问题：

1. ```接收并保持和客户端的连接```
2. ```socket读，socket写```

在高并发场景下面，就衍生了相应的两个问题

1. 服务端如何维持大量的客户端连接❓
2. 如果处理socket上的读写事件❓



一个三次握手成功后建立的tcp连接，在linux当中就是一个socket连接，一个socket连接在linux系统当中占用的内存大约是3KB（参考https://zhuanlan.zhihu.com/p/25241630）







首先要客户端得能成功连接上服务器，服务器软件需要有能力维持大量的tcp连接，要想做到这一点

1. 修改系统配置，增加一个进程能够访问的文件描述符数量上限，hold住流量；
2. 使用高效的I/O模型，让并发请求得到“妥善”处理，不拖垮系统；
3. 增加系统内存大小，每一个socket连接都是需要一定内存空间；











比如nginx高并发优化思路

1. ```硬件```：拓展服务器CPU和内存；
2. ```系统```：优化Linux内核参数；
3. ```软件```：优化nginx配置；



Linux内核优化

```shell
vim /etc/sysctl.conf		#修改内核参数文件
添加：
net.core.netdev_max_backlog = 262144			#每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许发送到队列的数据包的最大数目
net.core.somaxconn = 262144						#调节系统同时发起的TCP连接数
net.ipv4.tcp_max_orphans = 262144				#设定系统中最多允许存在多少tcp套接字不被关联到任何一个用户文件句柄上
net.ipv4.tcp_max_syn_backlog = 262144			#记录的那些尚未收到客户端确认信息的连接请求的最大值
net.ipv4.tcp_tw_recycle = 1						#开启TCP连接中TIME-WAIT sockets的快速回收
net.ipv4.tcp_tw_reuse = 1						#允许将TIME-WAIT sockets重新用于新的TCP连接
net.ipv4.tcp_syncookies = 0						#当出现SYN等待队列溢出时，禁用cookies来处理
net.ipv4.tcp_synack_retries = 1					#设置内核放弃TCP连接之前向客户端发送SYN+ACK包的数量
net.ipv4.tcp_ack_retries = 1					#该参数的作用与上一个参数类似，设置内核放弃建立连接之前发送SYN包的数量

sysctl -p		#执行操作
```



Nginx优化

```shell
vim /usr/local/nginx/conf/nginx.conf
覆盖(根据里面的参数进行修改)：
全局域:
worker_processes  8;			#工作进程数
worker_cpu_affinity 0001 0010 0100 1000 0001 0010 0100 1000;	#指定cpu内核来运行工作进程，我的是四核CPU，所以是这样，如果是八核CPU就是00000001 00000010 00000100 00001000 00010000 00100000 01000000 10000000，以次类推
worker_rlimit_nofile 65535;		#工作进程最大打开文件数

event域:
use epoll;						#使用epoll事件驱动模型
worker_connections 65535;		#工作进程最大连接数
multi_accept on;				#设置工作进程同时接收多个网络连接

http域:
sendfile on;					#允许sendfile方式传输文件
send_timeout 10s;				#设置服务器和客户端连接超时时间
client_header_buffer_size 4k;	#客户端请求头部的缓冲区大小
tcp_nopush on;					#在一个数据包里发送所有头文件，而不一个接一个的发送
tcp_nodelay on;				#不要缓存数据
keepalive_timeout 0;	#服务器和客户端保持活动的时间是65秒，60秒后服务器和客户端断开连接，高并发时可以设置为0
```









## web/应用服务器

讨论之前，需要明确两个概念，web服务器和应用服务器

| 比较项目   | 设计目的                                               | 是否支持动态内容                             |
| ---------- | ------------------------------------------------------ | -------------------------------------------- |
| web服务器  | 处理HTTP协议，提供静态内容                             | 通过插件支持Shell、PHP、Python等，不支持Java |
| 应用服务器 | 不限协议，主要提供动态内容，就像调用一个程序/方法/接口 | 支持                                         |



###web服务器

通过插件，可能让web服务器也能提供动态内容，但是web服务器有很多，不同种类支持插件的方式不同。web服务器的长处在于处理静态资源的请求，Apache和Nginx就是典型的web服务器，

web服务器主要就是进行文件和网络I/O，这个过程包括几个阶段：接收连接（网络I/O） -> 接收请求输入（网络I/O） -> 读取文件（文件I/O） -> 发送文件内容到socket（网络I/O），



nginx的优势在于它的I/O模型，可以充分利用多核CPU，处理大量并发连接，



Apache也是web服务器，





### 应用服务器

应用服务器的设计是用来实现RPC的，它通过网络方式暴露业务功能，理论上使用任何应用层协议都可以，只要调用端和被调用端统一即可。Tomcat是一个应用服务器，但是也提供了web服务器的功能，



我们开发的应用服务，要求开发效率高，但这会造成一个问题，就是代码的质量不高，程序运行的效率较低，而要提升程序的运行效率，需要花更多的时间去考究，去思考方案，必然导致开发效率降下来。所以一般开发的应用程序，程序的性能较低，支持的并发数有限。



Java世界中的应用服务器：Tomcat，Jetty，Undertow，这几个都支持Servlet规范。









### 最佳实践

由于web服务器非常适合用于提供静态内容，而应用服务器适合提供动态内容，因此大多数生产环境都有web服务器充当应用服务器的反向代理。这意味着在页面请求时，web服务器会通过提供静态内容(例如图像/静态HTML)来解释请求，并且它还会使用某种过滤技术(主要是请求资源的扩展)识别动态内容请求，并透明地转发到应用服务器。







网页展示的内容分为静态和动态两种，静态的内容就是不管什么客户端发送来的请求，返回的结果都是一样的，这些请求从根本上来说都是文件请求，响应内容就是文件数据。而动态则是不同的请求返回的内容可能是变化的，是需要经过业务处理才能确定响应的内容，既然需要业务逻辑处理，那肯定就是需要执行业务代码，这就需要接收请求的进程去调用业务代码了。

包含业务逻辑的程序那么多种类，接收到HTTP请求的web服务器，如何借助这些业务程序的力量，处理请求，输出响应呢，这里进行了模块划分



既然业务代码要嵌入到正常的处理流程里面，那web服务器的请求处理过程设计成什么样子的，有一些需要考虑的点，



<img src="https://tuchuang-1256253537.cos.ap-shanghai.myqcloud.com/img/image-20201006102926320.png" alt="image-20201006102926320" style="zoom:50%;" />







## 遗留问题

1. 作为静态资源服务器时，nginx为什么比apache性能好，原因是什么❓
2. Tomcat作为静态资源服务器为什么性能差❓









## 其他



如何保证服务的稳定性，99.9%的可用性，避免服务宕机，一方面需要良好的可用性架构，另一方面，需要可靠的软件，比如nginx。









## 参考

Web 服务器与应用服务器的区别是什么？ - wind的回答 - 知乎 https://www.zhihu.com/question/20096067/answer/226652400

