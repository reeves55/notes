# 网络协议

 网络协议只要记住，七层/四层网络模型，数据在不同主机之间传输都是经过网络这么几层，出问题也就这几层，网络协议是为了实现两台主机之间网络通信



## 分层网络模型

网络中的数据传输是一个非常复杂的过程，涉及到多种硬件设备，网络协议分层实际上就是把复杂的问题进行切分，每个层次解决一种问题，```降低整体设计复杂度```。下层为上层提供统一的服务，每个层次可以 ```灵活``` 变化，只要遵守协议即可。



<img src="https://tuchuang-1256253537.cos.ap-shanghai.myqcloud.com/tuchuang/1731440-20200317205443844-1998935516.png" alt="img"/>



B/S 架构中，数据是如何传输的

客户端浏览器需要访问一个url => DNS域名解析 => 构造应用层数据 => 发送IP数据报 => 把IP数据报通过数据链路层发送给路由器 => 路由器通过数据链路层发送给下一个路由器 ... => 路由器发送给局域网内的服务器



DNS解析一般需要 ```20-200ms```，如果本地没有DNS缓存的话，就需要到DNS服务器去查询，到DNS服务器查询就比较费时间了🐶

DNS解析次序：```进程内缓存```（比如说浏览器） -> ```系统缓存``` -> ```路由器缓存``` -> ```ISP DNS缓存``` - ```递归搜索```



参考：

https://www.jianshu.com/p/8fe17253f728



四层负载均衡，七层负载均衡

<img src="https://tuchuang-1256253537.cos.ap-shanghai.myqcloud.com/tuchuang/v2-b6a41680843e194047942c59210a6f32_1440w.jpg" alt="img" style="zoom:50%;" />



四层负载均衡接受网络请求，根据IP和Port，把这个数据包转发给后台服务器处理，并记录下这个 TCP 或者 UDP 的流量是由哪台服务器处理的，后续这个连接的所有流量都同样转发到同一台服务器处理。



四层负载均衡软件&硬件

* F5：硬件负载均衡器，功能很好，但是成本很高
* lvs：重量级的四层负载软件
* nginx：轻量级的四层负载软件，带缓存功能，正则表达式较灵活
* haproxy：模拟四层转发，较灵活



七层负载均衡软件

* haproxy：天生负载均衡技能，全面支持七层代理，会话保持，标记，路径转移
* nginx：只在 http 协议和 mail 协议上功能比较好，性能与 haproxy 差不多
* apache：功能较差
* Mysql proxy：功能尚可



参考：

https://www.cnblogs.com/magic-sea/p/12513310.html

https://www.cnblogs.com/jojoword/p/10835102.html



## IP协议

负责：```将数据包从一台主机送达到另一台主机```，只负责投递，中间遇到啥问题不管



网络层只有ip协议就可以了么？并不是

和IP协议配套使用的还有三种协议：

1. **地址解析协议ARP**（Address Resolution Protocol）
2. **网际控制报文协议ICMP**（Internet Control Message Protocol）
3. **网际组管理协议IGMP**（Internel Group Message Protocol）



ICMP和IGMP协议是基于IP协议来实现的，而IP协议要使用ARP协议



### ARP协议

```ICMP，IGMP``` -> ```IP``` -> ```ARP```

<img src="https://tuchuang-1256253537.cos.ap-shanghai.myqcloud.com/tuchuang/image-20200813181614371.png" alt="image-20200813181614371" style="zoom:50%;" />



ARP协议是将ip地址转换成数据链路层的MAC地址，因为数据链路层只使用MAC地址，而不使用IP地址，所以IP协议一定是要使用到ARP协议的，ARP协议的两个关键点就是 ```ARP本机缓存``` 和 ```局域网ARP请求广播```



<img src="https://tuchuang-1256253537.cos.ap-shanghai.myqcloud.com/tuchuang/image-20200813183628760.png" alt="image-20200813183628760" style="zoom:50%;" />



⚠️ 注意：在数据链路这一层，全世界存在着各式各样的网络，它们使用不同的硬件地址，要使得这些异构的网络能够通信，就需要进行复杂的硬件地址转换工作，而ARP就是干这件事儿的，在一个局域网里，主机之间使用局域网特定的硬件地址进行通信，而在局域网之外，要靠路由器传递数据包，而路由器之间也是使用指定的数据链路层协议传输数据的，可能和路由器所在的局域网不同。



### ICMP协议

它是IP报文的一种，实际上是把ICMP报文内容放在IP报文的数据部分，，类型有两种：```1. 差错报告报文```；```2. 询问报文```；差错报文可以让路由器给发信方一个数据报发送失败的反馈，告诉发信方 ”你包没发出去！“。

<img src="https://tuchuang-1256253537.cos.ap-shanghai.myqcloud.com/tuchuang/image-20200813223341653.png" alt="image-20200813223341653" style="zoom:50%;" />



<img src="https://tuchuang-1256253537.cos.ap-shanghai.myqcloud.com/tuchuang/image-20200813223404753.png" alt="image-20200813223404753" style="zoom:50%;" />



在下面👇的IP协议说明里面，可以看到IP协议报文会包含它携带的数据部分是什么类型的上层报文的，如果是ICMP报文，协议里面会标识出来。





#### ICMP协议的应用



##### PING命令

ping用来测试两台机器的连通性，它的原理是发送方向接收方发送一个ICMP 回送（Echo）请求，然后接收方在接收到这个回送请求时，会发送一个对应的 回答报文，发送端接收到回答报文之后，通过发送到接收的时间差计算出time，



##### traceroute命令

发送方向目标主机发送一串的IP数据报，每个数据报的TTL依次加1，当中间路由器发现TTL减为0的时候，会向发送方返回一个 ICMP 终点不可达的差错报文，发送方就靠这个知道IP数据报从起点到终点经过了哪些路由器的。





### IP协议

几个核心点：```IP地址```，```有限长度的数据报文```，```尽最大努力送达```

IP网络当中传输的数据单元是数据报，数据报的格式如下：

<img src="https://tuchuang-1256253537.cos.ap-shanghai.myqcloud.com/tuchuang/image-20200810104158015.png" alt="image-20200810104158015" style="zoom:50%;" />

**首部长度**

占用4位（值范围为 0 ~ 15），单位4字节（32位），一般值为 5（也就是首部是 5 * 4字节 = 20字节），也是ip数据报没有任何可选字段时的首部长度，首部最大占用 15 * 4字节 = 60字节



**总长度**

可以看到ip数据报的总长度字段占16位，理论上来说ip数据报的总长度上限为 2^16 -1 = 65535字节，但是这是达不到的，为什么呢，因为下层的数据链路层，一般都会规定最大传送单元MTU（Maximum Transfer Unit），最常用的 以太网的MTU就是1500字节，所以ip数据报在传输的时候一般都是需要经过切分的。



**🐧协议**

其实tcp协议当中已经包含了数据报当中的数据属于什么协议，这样

![image-20200810104852966](https://tuchuang-1256253537.cos.ap-shanghai.myqcloud.com/tuchuang/image-20200810104852966.png)



首部校验和

注意，这里的CRC首部校验和 ```只校验首部```，而 ```不会对数据进行任何校验```





## TCP协议

TCP核心就是可靠传输，```可靠``` 两个字很关键，为什么传输层要有可靠这层功能呢，是因为它的底层-网络层，只提供最大努力交付的数据报服务

**负责保证数据可靠地投递到接收端**，几大绝招：

```面向连接```：检测主机之间的可达性

```滑动窗口```（流量控制，数据按字节编号保证顺序，停止等待，超时重传）：保证接收方来得及接收，收到正确且顺序的数据

```拥塞避免```：拥塞是网络给发送端的限制信息，而滑动窗口是接收端对发送端的限制信息，但这两个都影响了发送端的滑动窗口大小，防止过多的数据注入到网络当中，tcp拥塞避免有几个关键机制，```慢开始```，```拥塞避免```，```快重传```，```快恢复```，发送端除了滑动窗口还有一个拥塞窗口











如何判断网络发生拥塞❓发送报文超时

慢开始：让拥塞窗口cwnd缓慢增大，每次发送出去的报文收到确认ACK，也就是一个往返RTT的时间，发送方的拥塞窗口就增加1，



tcp传输的单元是报文段

<img src="https://tuchuang-1256253537.cos.ap-shanghai.myqcloud.com/tuchuang/image-20200812223503920.png" alt="image-20200812223503920" style="zoom:50%;" />



### 可靠传输原理

TCP报文段包含了要发送数据字节流当中的 ”一段“ 字节数组，TCP协议就是负责把上层交给TCP协议的一长串字节流切分成多个TCP报文段，一个个发送给对方，





滑动窗口







为什么TCP要有MSS

TCP协议当中，发送方是以报文段为单位进行发送的，一个TCP报文段包含多个字节的数据，如果MSS设置得过大，就会导致一个TCP报文段在IP层会切分成多个IP报文（IP层要考虑数据链路层的MTU），每个IP报文独立发送，由于IP报文发送可能有传输失败的风险，一个TCP报文段越长，整体传输失败概率就越高，而一个TCP报文段一旦传输失败，就得重新传输（TCP一次发送一个报文段，而不是一个字节）





参考：

http://blog.kongfy.com/2015/07/tcp-maximum-segment-size-mss/







### 三次握手





> 如果TCP连接过程中，第三次握手失败怎么办？
>

server给client返回一个SYN+ACK报文后server进入SYN_RCV状态。client收到SYN+ACK报文后进入ESTABLISHED状态，并且给server返回一个ACK报文。

server端发送了SYN+ACK报文后就会启动一个定时器，等待client返回的ACK报文。如果第三次握手失败的话client给server返回的ACK报文，在传输过程中出现故障，server并不能收到这个ACK报文。那么server端就会启动超时重传机制，超过规定时间后重新发送SYN+ACK，重传次数根据/proc/sys/net/ipv4/tcp_synack_retries来指定，默认是5次。如果重传指定次数到了后，仍然未收到ACK应答，那么一段时间后，server自动关闭这个连接。但是client认为这个连接已经建立，如果client端向server写数据，server端将以RST包响应，方能感知到server的错误。





### 四次挥手







### TCP连接

一个TCP连接的成本

1. ```时间成本```：TCP连接建立需要进行3次握手，断开连接需要4次挥手，都很耗费时间；
2. ```CPU成本```：TCP连接、断开的数据包需要CPU进行处理，耗费CPU资源；
3. ```存储成本```：每个TCP连接对应着一个socket，而每个socket都有几个缓存，tcp_rmem、tcp_wmem、tcp_mem



### TCP长连接，短连接

看单个客户端和服务器之间的数据交互情况，<span style="color:red">如果客户端需要和服务器进行频繁的数据交互，那长连接就比较合适</span>，这种情况使用短连接一方面会造成客户端平均请求时间较长，另一方面服务端需要频繁创建和销毁资源，浪费服务端性能；

<span style="color:red">如果客户端和服务端交互次数较少，使用短连接合适</span>，这个时候使用长连接只会占用连接，浪费服务端资源；



#### TCP长连接

* 优点：复用连接，平均请求时间短（不用建立连接，断开连接了），服务端可以主动发送数据给客户端

* 缺点：如果连接上请求频度低，则会导致服务器端连接占用很多系统资源，却没有用，资源浪费



> 如何在TCP长连接长时间没有数据交互的情况下，回收资源❓

三个核心参数：```net.ipv4.tcp_keepalive_time``` 表示当客户端和服务器没有数据交互后，服务器等待这么一段时间（闲置时间，默认7200s），不去检测客户端的状态，等过了闲置时间之后，服务端就会向客户端发送侦测包（数据为空的报文），如果没有收到客户端的ACK，则会再 ```tcp_keepalive_intvl``` 时间后再次发送侦测包，最多尝试 ```tcp_keepalive_probes```次，如果重试次数达到最大，则服务端认为客户端已经不可达了（有可能客户端崩溃、强制关闭了应用、主机不可达等等）



#### TCP短连接

* 优点：用完就关闭，不会浪费服务端资源，服务端不需要同时维护大量连接
* 缺点：tcp连接利用率低，





### HTTP协议



#### 状态码

| 状态码 | 类别                          | 原因短语                           |
| ------ | ----------------------------- | ---------------------------------- |
| 1xx    | Informational（信息性状态码） | 接受的请求正在处理                 |
| 2xx    | Success（成功状态码）         | 请求正常处理完毕                   |
| 3xx    | Redirection（重定向）         | 需要进行附加操作以完成请求         |
| 4xx    | Client error（客户端错误）    | 客户端请求出错，服务器无法处理请求 |
| 5xx    | Server Error（服务器错误）    | 服务器处理请求出错                 |



```200 OK```：表示从客户端发送给服务器的请求被正常处理并返回；

```204 No Content```：表示客户端发送给客户端的请求得到了成功处理，但在返回的响应报文中不含实体的主体部分（没有资源可以返回）；

```206 Patial Content```：表示客户端进行了范围请求，并且服务器成功执行了这部分的GET请求，响应报文中包含由Content-Range指定范围的实体内容



```301 Moved Permanently```：永久性重定向，表示请求的资源被分配了新的URL，之后应使用更改的URL

```302 Found```：临时性重定向，表示请求的资源被分配了新的URL，希望本次访问使用新的URL

```303 See Other```：表示请求的资源被分配了新的URL，应使用GET方法定向获取请求的资源

```304 Not Modified```

```307 Temporary Redirect```：临时重定向，与303有着相同的含义，307会遵照浏览器标准不会从POST变成GET；（不同浏览器可能会出现不同的情况）



```400 Bad Request```：表示请求报文中存在语法错误

```401 Unauthorized```：未经许可，需要通过HTTP认证

```403 Forbidden```：服务器拒绝该次访问（访问权限出现问题）

```404 Not Found```：表示服务器上无法找到请求的资源，除此之外，也可以在服务器拒绝请求但不想给拒绝原因时使用



```500 Inter Server Error```：表示服务器在执行请求时发生了错误，也有可能是web应用存在的bug或某些临时的错误时

```503 Server Unavailable```：表示服务器暂时处于超负载或正在进行停机维护，无法处理请求





## UDP协议















## Linux socket编程



### Linux中的TCP连接





客户端

```c

```

客户端想要建立tcp或者udp连接，实际上是需要指定ip地址和端口号的，也就是说linux的socket实际上不仅是传输层协议的封装，其实也指定了ip层当中目的ip地址。





服务端

```c
int listen(int sockfd, int backlog);
```











## HTTP协议





一个HTTP请求由4部分主体构成：

![](https://tuchuang-1256253537.cos.ap-shanghai.myqcloud.com/tuchuang/http-message.jpg)



**请求行** *<回车符><换行符>*

**请求头字段名 : 请求头字段值** *<回车符><换行符>*

**...**

*<回车符><换行符>*

**请求体**



HTTP是超文本传输协议，传输的内容是字符文本格式。







### 不同Content-Type和请求体格式对应关系

> application/x-www-form-urlencoded



使用场景：表单提交参数

请求体格式：param1=value1&param2=value2&...

示例：name=lizhongcheng&age=24

Spring处理方式：解析http request body，这个时候request body实际上是byte数组，spring会解析byte数组，根据 &, = 等符号来解析参数的名字和值。还需要注意的是，此时的request body实际上是经过url encode的，所以解析之前首先是需要进行url decode。



> multipart/form-data











默认的http request body的编码是：

```java
private static final Charset DEFAULT_BODY_CHARSET = StandardCharsets.ISO_8859_1;
```

但是在处理请求的时候会从请求头里面的content-type里面尝试获取charset，如果有的话，就设置成请求当中指定的编码格式。



###注意

Java的Http server会操作操作系统级别的socket API，得到byte[]，这个数据就是应用层的数据，网络分层协议决定了传输层不关心应用层数据的格式，TCP只把应用层的数据当成字节流进行传输，操作系统的socket是对传输层协议的一层封装，不会对应用层数据进行解析，所以，Java http server需要自己处理字节数组格式的http应用层数据，即，按照http协议格式解析字节数组。HTTP1.1协议规定，请求行以及请求头中的属性都是使用US-ASCII码编码，而请求头的属性值和请求体的编码不是固定的。应用层可以直接使用US-ASCII编码规范来解析http字节流得到请求行和请求头，至于请求体，就要看http请求头当中有没有指定请求体的内容编码格式了。



