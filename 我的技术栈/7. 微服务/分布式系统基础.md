# 分布式系统基础





## 主演





<img src="https://tuchuang-1256253537.cos.ap-shanghai.myqcloud.com/img/365c0d94-eefa-11e5-90ad-9d74804ca412.png" alt="365c0d94-eefa-11e5-90ad-9d74804ca412" style="zoom: 40%;" />



### 0. 应用/API 网关







### 1. 注册中心



redis作为注册中心





### 2. Provider

通过把某种服务从整个系统独立出来，给了服务成长的空间，让专业的服务做专业的事。服务为上层应用提供服务，属于基础服务，正是由于它是基础服务，所以不能轻易出问题，还得



#### *缓存服务*

redis





#### *持久化存储服务*



##### 数据库









#### *消息队列*





#### *搜索引擎*



#### *断路器*

在分布式系统当中，服务之间存在依赖关系，一个服务可能业务流程中需要调用其他多个服务，这些服务的健康情况和网络状态都会对一个服务的业务流程产生影响，其实在分布式系统当中调用某个服务只有两种结果：

* 正常调用，网络状况正常，依赖服务正常
* 调用失败，网络延迟 / 网络断开 / 依赖服务出错







### 3. Consumer

consumer关键的组件包括：```RPC框架```，```客户端负载均衡```，```断路器```



<img src="https://tuchuang-1256253537.cos.ap-shanghai.myqcloud.com/img/image-20200320134526955.png" alt="image-20200320134526955" style="zoom:50%;" />



##### 客户端负载均衡算法

* 轮询（Round Robin）

  按顺序均匀地请求集群服务中的每一个单点，不关心单点的服务负载。轮询有一个问题，就是客户端可能有并发的请求，而每次请求都需要按照固定顺序去请求服务节点，这就需要进行线程同步，保证一个请求完了，下一个请求使用的是下一个服务节点，会有一定的性能损失。

* 随机（Random）

  按照长时间的维度来看的话，随机算法最终趋近于轮询算法，但是客户端在请求的时候，如果多线程并发去请求集群服务，线程之间互不影响，直接随机选一个就行了，就没有上面那个需要线程同步的过程，性能会更好一点

* 原地址哈希算法（Hash）

  通过对客户端ip地址进行hash，再用hash值取模去匹配要请求的服务节点，当服务节点数量不变的情况，同一个客户端ip多次请求，都会被负载均衡指向同一个服务节点

* 加权轮询（Weight Round Robin）

  给不同的服务节点施加不同的负载，这在服务节点性能有明显差距的时候可以使用，让性能高的节点处理更多的负载，具体怎么做呢，假设有三个服务节点 1, 2, 3，他们的权重分别是 1, 2, 3，权重越高，分配的负载也越高，那在客户端可以这样做，用一个数组存储当前节点请求时要访问的服务节点，那么这个带有权重信息的数组值为 [1, 2, 2, 3, 3, 3]，客户端还是按照轮询的算法来根据这个数组，每次请求都使用上一个请求所使用的数组索引+1指定的服务节点，这样就能做到加权轮询，但是问题还是和轮询一样，并发请求需要加锁同步，保证请求严格按照顺序

* 加权随机（Weight Random）

  和加权轮询一样，带权重的服务节点数组为[1, 2, 2, 3, 3, 3]，但是每次都使用随机数确定此次请求的数组索引

* 最小连接数算法（Least Connections）

  每次客户端请求服务节点时，都请求当前负载压力最小的一个节点




##### 断路器

断路器的核心作用是 “保护”，核心目的是保证可用性，保护当前服务不会因为依赖的服务出现异常而导致当前服务的不可用。基本思想就是，当调用其他服务出现出错时，为了不因为外部服务的不可用而影响当前服务的健康状况，对出错的服务进行 “断路”，进行“隔断”，用默认的降级策略替代出错的服务，从而保证当前服务的可用性。



##### RPC框架



RPC框架底层，在操作系统层面上其实就是socket，socket相关的核心函数如下：

```c
// 创建socket（成功时返回非负描述符，失败返回-1）
int socket(int family, int type, int protocol);

// 发起TCP连接（成功通过三次握手建立连接时返回0，失败返回-1）
int connect(int sockfd, const struct sockaddr *servaddr, socklen_t addrlen);

// 绑定socket到某个网络地址（IP:Port）
int bind(int sockfd, const struct sockaddr *myaddr, socklen_t addrlen);

// 将TCP连接状态设置为 LISTEN, backlog指定内核应该为套接字排队的最大连接个数
int listen(int sockfd, int backlog);

// 从已完成连接队列头返回一个已经完成连接的套接字描述符
int accept(int sockfd, struct sockaddr *cliaddr, socklen_t *addrlen);

// 发送数据（只有当socket处于connected状态可调用）
// 阻塞模式下，如果发送缓存已满，此方法阻塞
// nonblocking模式下，发送缓存已满则返回 EAGAIN/EWOULDBLOCK 错误
ssize_t send(int sockfd, const void *buf, size_t len, int flags);

// 从指定socket接收数据
// 阻塞模式下，如果socket接收缓存中没有数据，则阻塞
// nonblocking模式下，接收缓存为空则返回 EAGAIN/EWOULDBLOCK 错误
ssize_t recv(int sockfd, void *buf, size_t len, int flags);
```

socket本身有两种 I/O 模式且可以设置，当处于阻塞模式时，所有需要等待操作完成的系统调用都会阻塞，例如```read``` 会阻塞等待到接收缓存已经有数据，而非负责模式下，原本会阻塞的系统调用则会立马返回一个错误码，用户线程不会阻塞，但相应的，也暂时无法知道所关心的socket指定事件什么时候发生，所以需要通过 ```select```、```poll``` 等方法来轮询socket上是否有对应事件发生。















### 4. 安全

信息安全三大要素：```保密性```，```完整性```，```可用性```

