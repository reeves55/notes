# 线程池



1. 为什么需要线程池❓

   关键点：```线程资源复用```，```阻塞队列缓冲任务```，

   对于<span style="color:red">运行时间短 </span>且 <span style="color:red">频繁运行</span>的任务，适合使用线程池，可以达到很好的线程复用的效果，资源利用率更高；
   
   



## ThreadPoolExecutor

常用构造方法为：

```java
ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)
```

1. ```corePoolSize```： 线程池维护线程的最少数量
2. ```maximumPoolSize```：线程池维护线程的最大数量
3. ```keepAliveTime```： 线程池维护线程所允许的空闲时间
4. ```unit```： 线程池维护线程所允许的空闲时间的单位
5. ```workQueue```： <span style="color:red">线程池所使用的缓冲队列</span>
6. ```threadFactory```：创建新线程的工厂
7. ```handler```： <span style="color:red">线程池对拒绝任务的处理策略</span>



handler的选择：

* ThreadPoolExecutor.AbortPolicy() ：抛出java.util.concurrent.RejectedExecutionException异常

* ThreadPoolExecutor.CallerRunsPolicy() : 重试添加当前的任务，他会自动重复调用execute()方法

* ThreadPoolExecutor.DiscardOldestPolicy() : 抛弃旧的任务
* ThreadPoolExecutor.DiscardPolicy() : 抛弃当前的任务





##### FutureTask

1. ```public void execute(Runnable command);```
2. ```Future<?> submit(Runnable task);```
3. ```public <T> Future<T> submit(Runnable task, T result);```
4. ```public <T> Future<T> submit(Callable<T> task);```



<img src="https://tuchuang-1256253537.cos.ap-shanghai.myqcloud.com/tuchuang/image-20200324221157738.png" alt="image-20200324221157738" style="zoom:55%;float:right;margin-right:40px" />

3个返回Future的方法实际上返回的都是 ```FutureTask``` 对象，既然FutureTask是线程池返回的，这个对象在线程池运行任务过程中，肯定会引用该对象，在主线程也是通过FutureTask来获取执行结果，就意味着这个对象至少被两个线程共享，线程池在任务执行结束肯定要唤醒等待在这个对象上的主线程，让主线程能够获取到结果返回继续运行，提交任务的时候是同步非阻塞的，在获取任务执行结果的时候是同步阻塞的。



<img src="https://tuchuang-1256253537.cos.ap-shanghai.myqcloud.com/tuchuang/image-20200324215900501.png" alt="image-20200324215900501" style="zoom:50%;" />









线程：

可以通过 ```setDamon(boolean on)``` ，把一个线程设置成守护线程，守护线程的存在不会影响JVM退出（只要有一个非守护线程运行，JVM就不会退出，否则JVM将会退出，JVM退出时，所有守护线程都会被停止）

线程组：

在Java当中，每一个线程都属于某个线程组，main线程属于 system 线程组，当我们在new Thread() 的时候，如果不指定当前线程属于哪个线程组，默认属于创建当前线程的线程所属的线程组，也就是 parent.getThreadGroup()，ThreadGroup可以批量interrupt组内线程。

![img](https://images2015.cnblogs.com/blog/801753/201510/801753-20151005180622909-789401754.png)