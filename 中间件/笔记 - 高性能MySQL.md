# 笔记 - 高性能MySQL

从高层次上来讲，数据库软件是为上层应用提供 <span style="color:red">格式化数据</span> 的 <span style="color:red">增删改查</span> 操作的组件，MySQL只操作格式化数据是由它的关系模型决定的，



### 什么是事务❓

事务是MySQL向上层应用提供的一个概念，我们在把业务上一个逻辑操作使用MySQL来实现时候，可能要对MySQL做多次物理操作才能实现，这里说的逻辑操作是抽象的概念上的，比如说 “转账” 这个操作，在使用MySQL实现的时候就需要好几个步骤才能实正确实现转账的功能（先扣掉一个人的余额，再增加另一个人的余额），这里转账就是概念上的逻辑操作，MySQL实际执行的操作就是物理操作，```Logic_Operation -> (Physical Operation1, Physical Operation2, ...) ``` ，就逻辑操作上来讲，有时我们需要该操作具有原子性，不管它具体需要几个步骤，但是这几个步骤要么都完成，要么一个都不做，但是在MySQL进行实际的物理数据操作时，每个操作都可能失败，这就导致一个逻辑操作在执行的时候，可能会出现 “执行一部分”的情况，而事务就是来解决这个问题的，事务可以让MySQL的一系列物理操作具有“一个操作”的特征，但事务不只原子性这一个特性：

* 原子性
* 持久性
* 隔离性（可调节）
* 一致性



####事务隔离性

事务的原子性自然不必多说，这是我们需要事务的一个重要理由，持久性也好理解，我们提交的事务必须得持久化到存储设备上，否则我们提交了事务结果事务执行的结果丢失，相当于没有执行事务，那这是不可接受的，但是就隔离性来说，是有考究的：

首先为什么需要隔离性❓为了提高数据库的效率，数据库允许多个事务并发执行，在这种情况下，一个事务在执行过程当中，它所“关注”的数据是可能发生变化的，比如说在事务执行过程中，数据被修改了，数据被删除了等等，<span style="color:red">正是由于事务并发（没有事务并发执行，就没有事务隔离性这个说法）</span>，可能导致的问题有：

* 脏读：当前事务读取到其他事务执行过程中修改的数据，由于其他事务可能失败rollback，那当前事务读取到的这个数据就可能是脏数据。
* 丢失修改：多个事务并发修改数据过程中，查询到数据的起始状态是相同的，但是多个事务对数据做了不同的更改，最终，只留下一个事务执行结果，其他事务执行结果被覆盖。
* 不可重复读：事务在执行过程中，执行相同的读操作，结果读取的结果是不同的，数据可能发生改变，可能被删除
* 幻读：事务执行过程中，新增了数据，事务中两次查询查出的数据条数多了

是并发导致了事务隔离问题，



![img](http://img.blog.itpub.net/blog/2019/11/04/5890997c0bb09cf5.jpeg?x-oss-process=style/bb)

















参考：

#### MySQL client-server 协议



MySQL server返回给客户端查询数据的结果，应用层使用的是MySQL自定义的协议格式，

这里记录一个踩坑日记，问题是：用连接池组件向数据查询数据时，发现datetime格式的数据时间错位，客户端解析出来的时间和数据库存储的时间不同，但是客户端和服务器端都使用相同的时区，数据库也使用相同的时区。

原因是使用数据库连接池连接MySQL server时，jdbc url没有设置时区信息，



MySQL服务器给客户端发送的ResultSet中，如果包含Date、DateTime、Timestamp类型的数据时，都采用以下的格式，可以看到，是没有时区信息的，所以连接MySQL的时候需要指定MySQL服务器数据库使用的时区，这样，才能正确解析MySQL服务器返回的日期的值。



<img src="https://tuchuang-1256253537.cos.ap-shanghai.myqcloud.com/img/image-20200320152458324.png" alt="image-20200320152458324" style="zoom:45%; float:left;border:1px solid" />



