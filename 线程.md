# 线程











线程是操作系统的概念，而不是CPU中的概念，CPU只负责执行指令，操作系统负责给CPU分配具体执行的线程。即：

* 线程在操作系统层次上创建
* CPU时间片由操作系统切分，一个时间片之后，操作系统进行线程调度



如果系统当中运行的线程数和CPU核数相等，理论上没有一个线程需要进行切换，都能在一个CPU核上一直运行。





### Linux线程是什么样的？





posix thread lib in linux：

https://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html





Linux线程池实现思路：

一个任务队列，每个任务指明了任务需要执行的函数和参数

一堆线程，每个线程都死循环尝试从任务队列中取出任务，然后执行任务中指定的函数，并传递给函数指定的参数





Java一个线程是如何重复利用的







### TreadPoolExecutor





```java
// ctl 状态控制变量，表示两个值
// 1. workerCount: 已经启动并且不会停止的线程数量
// 2. runState: 线程池当前所处的生命周期状态
```





负数使用相应正数经过反码运算之后表示

```java
// -127的表示
// 相应正数为 01111111
// 1. 取反
// 1000000
// 2. 加1
// 10000001 <- 这就是-127实际存储的值

// 负数解码
// 1. 减1
// 10000000
// 2. 取反
// 01111111 <- 这是负数的正数值，没有符号位，就是127，因此此负数表示的是-127
```





### Spring RequestContextHolder

用来保存当前的HTTP请求信息的，是对HttpServletRequest的一个包装，关键方法有：

```java
// 线程安全的 requestAttributesHolder
// 每个线程都有一个 RequestAttributes对象
private static final ThreadLocal<RequestAttributes> requestAttributesHolder =
            new NamedThreadLocal<RequestAttributes>("Request attributes");

// 获取当前请求相关信息  你   s'd
public static RequestAttributes getRequestAttributes() {
    RequestAttributes attributes = requestAttributesHolder.get();
    if (attributes == null) {
        attributes = inheritableRequestAttributesHolder.get();
    }
    return attributes;
}

public static void setRequestAttributes(@Nullable
                                        RequestAttributes attributes,
                                        boolean inheritable);

public static RequestAttributes currentRequestAttributes()
                                                  throws IllegalStateException;

public static void resetRequestAttributes();
```



RequestAtrributes是一个接口，接口方法有：

| 返回值     | 方法描述                                                     |
| ---------- | ------------------------------------------------------------ |
| `Object`   | `getAttribute(String name, int scope)`Return the value for the scoped attribute of the given name, if any. |
| `String[]` | `getAttributeNames(int scope)`Retrieve the names of all attributes in the scope. |
| `String`   | `getSessionId()`Return an id for the current underlying session. |
| `Object`   | `getSessionMutex()`Expose the best available mutex for the underlying session: that is, an object to synchronize on for the underlying session. |
| `void`     | `registerDestructionCallback(String name, Runnable callback, int scope)`Register a callback to be executed on destruction of the specified attribute in the given scope. |
| `void`     | `removeAttribute(String name, int scope)`Remove the scoped attribute of the given name, if it exists. |
| `Object`   | `resolveReference(String key)`Resolve the contextual reference for the given key, if any. |
| `void`     | `setAttribute(String name, Object value, int scope)`Set the value for the scoped attribute of the given name, replacing an existing value (if any). |



**Spring框架在DispatchServlet处理一个HTTP请求的逻辑中，执行具体请求处理方法前，会调用RequestContextHolder中的setRequestAttributes()方法：**

```java
// DispatchServlet从父类FrameServlet中继承的方法
protected final void processRequest(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {

        long startTime = System.currentTimeMillis();
        Throwable failureCause = null;

        LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();
        LocaleContext localeContext = buildLocaleContext(request);

        RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();
        ServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes);

        WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);
        asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), new RequestBindingInterceptor());

        //关键方法：将RequestAttributes设置到RequestContextHolder
        initContextHolders(request, localeContext, requestAttributes);

        try {
            //具体的业务逻辑
            doService(request, response);
        }
        catch (ServletException ex) {
            failureCause = ex;
            throw ex;
        }
        catch (IOException ex) {
            failureCause = ex;
            throw ex;
        }
        catch (Throwable ex) {
            failureCause = ex;
            throw new NestedServletException("Request processing failed", ex);
        }

        finally {
            //重置RequestContextHolder之前设置RequestAttributes
            resetContextHolders(request, previousLocaleContext, previousAttributes);
            if (requestAttributes != null) {
                requestAttributes.requestCompleted();
            }

            if (logger.isDebugEnabled()) {
                if (failureCause != null) {
                    this.logger.debug("Could not complete request", failureCause);
                }
                else {
                    if (asyncManager.isConcurrentHandlingStarted()) {
                        logger.debug("Leaving response open for concurrent processing");
                    }
                    else {
                        this.logger.debug("Successfully completed request");
                    }
                }
            }

            publishRequestHandledEvent(request, response, startTime, failureCause);
        }
    }


// 在这里设置RequestContextHolder
    private void initContextHolders(
            HttpServletRequest request, LocaleContext localeContext, RequestAttributes requestAttributes) {

        if (localeContext != null) {
            LocaleContextHolder.setLocaleContext(localeContext, this.threadContextInheritable);
        }
        if (requestAttributes != null) {
            RequestContextHolder.setRequestAttributes(requestAttributes, this.threadContextInheritable);
        }
        if (logger.isTraceEnabled()) {
            logger.trace("Bound request context to thread: " + request);
        }
    }
```



参考：

https://www.jianshu.com/p/80165b7743cf





### ThreadLocal的原理

ThreadLocal相当于一个容器，只不过只能放进去一个值而已，关键是这个值是每个线程都会持有一份的，ThreadLocal变量放在哪里都无所谓，重要的是它的get()方法和set()方法，get()方法在当前线程上下文中获取一个值，set()方法在当前线程上下文中设置一个值。



| 知识面       | 知识点                                                  | 描述                                                         |
| ------------ | ------------------------------------------------------- | ------------------------------------------------------------ |
| JVM 垃圾回收 | 四种```Reference```类型，强引用，软引用，弱引用，虚引用 | 软引用和弱引用虽然一般都作为缓存场景中，但是软引用的缓存是在内存实在不够用的时候，回收掉，回收之前，都是一直有用的，而弱引用就不一样了，这种缓存其实可能只用几次就不用了不会一直用，所以及时回收才是正道 |



### Object notify wait & synchronized

基于一个对象的锁，锁是什么概念，锁可以理解为打开新世界的钥匙，是一个令牌，只有拿到这个锁，才能做某些事情，所以我们用 ```synchronized(obj)```，```ReentrantLock lock = new ReentrantLock(); lock.lock();```，锁的使用必然和某个实体直接相关，那个实体就是锁，拥有实体的线程才能执行某一部分的代码，而实体仅有一份，两者结合，保证了线程同步执行。





Object的 ```notify ``` 和 ```wait``` 系列方法是用来和 ```synchronized``` 关键字配合使用，实现使用同一个资源的并发线程可以进行通知的操作。配合使用的方法就是synchronized锁住的对象和用来通知的对象是同一个对象

```java
Object obj = new Object();

// thread 1 后执行
Thread.sleep(1000);

synchronized(obj) {
  System.out.println("thread 1 get monitor and notify thread2");
	obj.notifyAll();
  System.out.println("leave thread 1");
}

// thread 2 先执行
synchronized(obj) {
  System.out.println("thread 2 will wait and handle out monitor");
  obj.wait();
  System.out.println("thread 2 continue to do something");
}

// 输出
// thread 2 will wait and handle out monitor
// thread 1 get monitor and notify thread2
// leave thread 1
// thread 2 continue to do something
```



### synchronized锁状态切换

JDK1.6之前，synchronized的性能远不及ReentrantLock，那是因为synchronized只有重量级锁，JDK1.6，synchronized做了大量的锁优化，性能已经和ReentrantLock持平。



**偏向锁**：偏向锁是为了一个同步代码块一直只有一个线程在访问的情形，不存在竞争。好处是这个时候线程访问同步代码块只需要判断锁的对象头的偏向锁指定的线程ID是否是当前线程即可，不需要其他复杂操作，效率极高（偏向锁如何从偏向一个线程切换成偏向另一个线程呢？）



**轻量级锁**：轻量级锁是为了一个同步代码块存在线程竞争情况，但是竞争不激烈，或者交替访问不竞争时的情形。



**重量级锁**：重量级锁是为了一个同步代码块多个线程激烈竞争的情况，许多线程抢占Monitor，线程同步访问代码块。

**自旋锁**：



**锁消除**：



**锁粗化**：







双重检查锁的单例模式，属于懒加载









###字符串为什么在Java中设计成不可变，如何实现不可变的？

**为什么这么设计**：<span style="color:red">1）</span>程序当中大量使用字符串，如果字符串能够缓存起来，必定能提高程序运行效率，但是如果是所有缓存的字符串池，多个变量的值相同时，那么它们肯定指向字符串池当中同一个对象，这个时候如果字符串是可变的话，一个程序改变了字符串的值，其他的变量都受到了影响，所以字符串得是不可变的才行。<span style="color:red">2）</span>安全问题，Java使用字符串来表示类的权限定名，也是通过类的名字来加载类的，如果字符串是可变的，就可能产生原先要加载类```java.io.Writer``` 变成了加载 ```mil.vogoon.DiskErasingWriter```； <span style="color:red">3）</span>String不可变，那么字符串对象就可以缓存起hashcode的值，这样String作为HashMap的Key时，就不需要先计算对象的hashcode了，效率更高。



**如何实现**：<span style="color:red">1）</span>String类是final的，不可继承，用户无法改变String特点；<span style="color:red">2）</span>实际存储字符串的char[]是private的，char变量是final类型的，无法改变char[]中的任何一个字符的值。